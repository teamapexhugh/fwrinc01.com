import React, { useState, useEffect } from 'react';
import { RotateCcw, ArrowLeftRight, History, Trophy, Minus, Play, Pause } from 'lucide-react';

const BadmintonScoreboard = () => {
  // 遊戲狀態設定
  const [matchState, setMatchState] = useState({
    teamA: { name: '隊伍 A', score: 0, sets: 0, color: 'bg-blue-600' },
    teamB: { name: '隊伍 B', score: 0, sets: 0, color: 'bg-red-600' },
    servingTeam: 'A', // 'A' or 'B'
    currentSet: 1,
    history: [], // 用於 Undo 功能
    setHistory: [], // 儲存每局比分: [{a: 21, b: 19}, ...]
    isMatchOver: false,
    winner: null,
    isSwapped: false, // 是否交換場地
    gameTime: 0,
    isTimerRunning: false
  });

  // 計時器邏輯
  useEffect(() => {
    let interval;
    if (matchState.isTimerRunning && !matchState.isMatchOver) {
      interval = setInterval(() => {
        setMatchState(prev => ({ ...prev, gameTime: prev.gameTime + 1 }));
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [matchState.isTimerRunning, matchState.isMatchOver]);

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const toggleTimer = () => {
    setMatchState(prev => ({ ...prev, isTimerRunning: !prev.isTimerRunning }));
  };

  // 儲存歷史紀錄 (為了 Undo)
  const saveHistory = () => {
    setMatchState(prev => {
      const newHistory = [...prev.history];
      if (newHistory.length > 10) newHistory.shift();
      const currentState = { ...prev, history: [] }; 
      newHistory.push(currentState);
      return { ...prev, history: newHistory };
    });
  };

  // Undo 功能
  const handleUndo = () => {
    setMatchState(prev => {
      if (prev.history.length === 0) return prev;
      const lastState = prev.history[prev.history.length - 1];
      const newHistory = prev.history.slice(0, -1);
      return { ...lastState, history: newHistory };
    });
  };

  // 檢查是否贏得該局
  const checkSetWin = (scoreOwn, scoreOpponent) => {
    if (scoreOwn >= 30) return true;
    if (scoreOwn >= 21 && scoreOwn - scoreOpponent >= 2) return true;
    return false;
  };

  // 得分邏輯
  const addPoint = (team) => {
    if (matchState.isMatchOver) return;
    saveHistory();
    setMatchState(prev => {
      let newState = { ...prev };
      
      if (team === 'A') {
        newState.teamA.score += 1;
        newState.servingTeam = 'A';
      } else {
        newState.teamB.score += 1;
        newState.servingTeam = 'B';
      }

      const scoreA = newState.teamA.score;
      const scoreB = newState.teamB.score;
      let setWon = false;
      let setWinner = null;

      if (checkSetWin(scoreA, scoreB)) {
        setWon = true;
        setWinner = 'A';
      } else if (checkSetWin(scoreB, scoreA)) {
        setWon = true;
        setWinner = 'B';
      }

      if (setWon) {
        newState.setHistory = [...newState.setHistory, { a: scoreA, b: scoreB }];
        
        if (setWinner === 'A') newState.teamA.sets += 1;
        else newState.teamB.sets += 1;

        if (newState.teamA.sets === 2) {
          newState.isMatchOver = true;
          newState.winner = 'A';
          newState.isTimerRunning = false;
        } else if (newState.teamB.sets === 2) {
          newState.isMatchOver = true;
          newState.winner = 'B';
          newState.isTimerRunning = false;
        } else {
          newState.teamA.score = 0;
          newState.teamB.score = 0;
          newState.currentSet += 1;
        }
      }
      return newState;
    });
  };

  // 扣分邏輯
  const minusPoint = (e, team) => {
    e.stopPropagation();
    saveHistory();
    setMatchState(prev => {
      let newState = { ...prev };
      if (team === 'A' && newState.teamA.score > 0) newState.teamA.score -= 1;
      if (team === 'B' && newState.teamB.score > 0) newState.teamB.score -= 1;
      return newState;
    });
  };

  // 交換場地
  const swapSides = () => {
    setMatchState(prev => ({ ...prev, isSwapped: !prev.isSwapped }));
  };

  // 重置比賽
  const resetMatch = () => {
    if (window.confirm('確定要重新開始比賽嗎？所有紀錄將被清除。')) {
      setMatchState({
        teamA: { name: '隊伍 A', score: 0, sets: 0, color: 'bg-blue-600' },
        teamB: { name: '隊伍 B', score: 0, sets: 0, color: 'bg-red-600' },
        servingTeam: 'A',
        currentSet: 1,
        history: [],
        setHistory: [],
        isMatchOver: false,
        winner: null,
        isSwapped: false,
        gameTime: 0,
        isTimerRunning: false
      });
    }
  };

  const leftTeamKey = matchState.isSwapped ? 'teamB' : 'teamA';
  const rightTeamKey = matchState.isSwapped ? 'teamA' : 'teamB';
  const leftTeamId = matchState.isSwapped ? 'B' : 'A';
  const rightTeamId = matchState.isSwapped ? 'A' : 'B';

  const TeamPanel = ({ teamKey, teamId }) => {
    const team = matchState[teamKey];
    const isServing = matchState.servingTeam === teamId && !matchState.isMatchOver;
    const isWinner = matchState.winner === teamId;

    return (
      <div 
        onClick={() => addPoint(teamId)}
        className={`flex-1 relative flex flex-col items-center justify-center p-6 cursor-pointer transition-all duration-200 active:opacity-90 ${team.color} ${isWinner ? 'ring-8 ring-yellow-400 z-10' : ''}`}
        style={{ touchAction: 'manipulation' }} // 防止雙擊縮放
      >
        <div className="absolute top-4 right-4 text-white/30 text-8xl font-black">
          {team.sets}
        </div>

        {isServing && (
          <div className="absolute top-8 left-8 animate-bounce">
            <div className="bg-white rounded-full p-2 shadow-lg">
               <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-800"><path d="M12 22v-9"/><path d="M7 10.5c0-2.5 2.2-4.5 5-4.5s5 2 5 4.5"/><path d="M12 2c-3.3 0-6 1.8-6 4 0 .9.5 1.7 1.3 2.3"/><path d="M16.7 8.3c.8-.6 1.3-1.4 1.3-2.3 0-2.2-2.7-4-6-4"/></svg>
            </div>
          </div>
        )}

        <input 
          value={team.name}
          onClick={(e) => e.stopPropagation()}
          onChange={(e) => {
            const val = e.target.value;
            setMatchState(prev => ({
              ...prev,
              [teamKey]: { ...prev[teamKey], name: val }
            }));
          }}
          className="text-3xl md:text-5xl font-bold text-white bg-transparent text-center outline-none border-b-2 border-white/20 focus:border-white mb-8 max-w-[80%]"
        />

        <div className="text-[10rem] md:text-[14rem] leading-none font-black text-white tabular-nums drop-shadow-xl select-none">
          {team.score}
        </div>

        <button 
          onClick={(e) => minusPoint(e, teamId)}
          className="mt-8 p-4 rounded-full bg-white/20 hover:bg-white/30 text-white transition-colors"
        >
          <Minus size={32} />
        </button>

        {isWinner && (
          <div className="absolute bottom-10 flex items-center gap-2 bg-yellow-400 text-black px-6 py-2 rounded-full font-bold text-2xl shadow-lg">
            <Trophy size={28} />
            WINNER
          </div>
        )}
      </div>
    );
  };

  return (
    // 使用 style 處理 iOS Safe Area
    <div 
      className="flex flex-col h-screen bg-gray-900 overflow-hidden font-sans select-none"
      style={{ 
        height: '100dvh', // 使用 dynamic viewport height 避免網址列遮擋問題
        paddingBottom: 'env(safe-area-inset-bottom)' // 確保內容不被 Home Bar 遮擋
      }}
    >
      {/* 頂部資訊列 */}
      <div 
        className="h-16 bg-gray-800 flex items-center justify-between px-6 shadow-md z-20 shrink-0"
        style={{ paddingTop: 'env(safe-area-inset-top)' }} // 避開劉海/動態島
      >
        <div className="flex items-center gap-4">
          <span className="text-gray-400 font-bold text-xl">SET {matchState.currentSet}</span>
          <div className="flex gap-2">
            {matchState.setHistory.map((h, idx) => (
              <span key={idx} className="bg-gray-700 text-gray-300 px-2 py-1 rounded text-sm">
                S{idx+1}: {h.a}-{h.b}
              </span>
            ))}
          </div>
        </div>

        <div 
          onClick={toggleTimer}
          className={`flex items-center gap-2 text-2xl font-mono font-bold cursor-pointer ${matchState.isTimerRunning ? 'text-green-400' : 'text-gray-500'}`}
        >
           {matchState.isTimerRunning ? <Pause size={20}/> : <Play size={20}/>}
           {formatTime(matchState.gameTime)}
        </div>

        <div className="flex items-center gap-2">
           <span className="text-xs text-gray-500 hidden md:block">Web App Ready</span>
        </div>
      </div>

      {/* 主計分區 */}
      <div className="flex-1 flex relative overflow-hidden">
        <TeamPanel teamKey={leftTeamKey} teamId={leftTeamId} />
        <div className="absolute top-0 bottom-0 left-1/2 w-1 bg-black/20 transform -translate-x-1/2 z-0"></div>
        <TeamPanel teamKey={rightTeamKey} teamId={rightTeamId} />
      </div>

      {/* 底部控制列 */}
      <div className="h-24 bg-gray-800 flex items-center justify-center gap-4 px-4 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.3)] shrink-0">
        <button 
          onClick={handleUndo}
          disabled={matchState.history.length === 0}
          className="flex flex-col items-center justify-center w-20 h-16 rounded-xl bg-gray-700 text-white hover:bg-gray-600 disabled:opacity-30 active:scale-95 transition-all"
        >
          <RotateCcw size={24} />
          <span className="text-xs mt-1">復原</span>
        </button>

        <button 
          onClick={swapSides}
          className="flex flex-col items-center justify-center w-20 h-16 rounded-xl bg-gray-700 text-white hover:bg-gray-600 active:scale-95 transition-all"
        >
          <ArrowLeftRight size={24} />
          <span className="text-xs mt-1">換邊</span>
        </button>

        <div className="w-px h-10 bg-gray-600 mx-2"></div>

        <button 
          onClick={resetMatch}
          className="flex flex-col items-center justify-center w-20 h-16 rounded-xl bg-red-900/50 text-red-200 hover:bg-red-900/80 active:scale-95 transition-all border border-red-800"
        >
          <History size={24} />
          <span className="text-xs mt-1">重置</span>
        </button>
      </div>
    </div>
  );
};

export default BadmintonScoreboard;
